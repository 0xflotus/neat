#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "../neat.h"
#include "../neat_internal.h"

/*
 * Note: Do not edit this file without updating the line numbers in the tutorial
 * in the documentation.
 */
static int read_raw=1;

//read 32 bytes on the raw socket
static void read_raw_socket(int fd) {
    unsigned char buffer[32];
    int raw_bytes_read=read(fd, buffer, 32);
    int error=errno;
    printf("[SM] bytes read: %d\n", raw_bytes_read);
    if(raw_bytes_read<0) {
	printf("[SM] errno: %d\n", error);
    }
    else {
	//printf("[SM] buffer: %s", buffer);	
	for(int i=0; i<raw_bytes_read; i++) {
		printf("%02x ", buffer[i]);	
	}
	printf("\n");
    }
}

static neat_error_code
on_readable(struct neat_flow_operations *ops)
{
    uint32_t bytes_read = 0;
    unsigned char buffer[32];

    //read the raw socket
    if(read_raw) {
        read_raw_socket(ops->flow->socket->fd);
    }    

    if (neat_read(ops->ctx, ops->flow, buffer, 31, &bytes_read, NULL, 0) == NEAT_OK) {
        buffer[bytes_read] = '\0';
        fprintf(stdout, "Read %u bytes: %s\n", bytes_read, buffer);
    }

    //neat_close(ops->ctx, ops->flow);
    //neat_stop_event_loop(ops->ctx);

    return NEAT_OK;
}

static neat_error_code
on_writable(struct neat_flow_operations *ops)
{
    //read the raw socket
    if(read_raw) {
        read_raw_socket(ops->flow->socket->fd);
    }
    
    unsigned char message[4]="Hi!";
    neat_write(ops->ctx, ops->flow, message, 3, NULL, 0);
    return NEAT_OK;
}

static neat_error_code
on_all_written(struct neat_flow_operations *ops)
{
    ops->on_readable = on_readable;
    ops->on_writable = NULL;
    neat_set_operations(ops->ctx, ops->flow, ops);
    return NEAT_OK;
}

static neat_error_code
on_connected(struct neat_flow_operations *ops)
{
    ops->on_writable    = on_writable;
    ops->on_all_written = on_all_written;
    neat_set_operations(ops->ctx, ops->flow, ops);

    //read the raw socket
    if(read_raw) {
        read_raw_socket(ops->flow->socket->fd);
    }

    //neat_stop_event_loop(ops->ctx);

    return NEAT_OK;
}

static char *properties = "{\n\
    \"transport\": [\n\
        {\n\
            \"value\": \"SCTP\",\n\
            \"precedence\": 1\n\
        },\n\
        {\n\
            \"value\": \"TCP\",\n\
            \"precedence\": 1\n\
        }\n\
    ]\n\
}";

int
main(int argc, char *argv[])
{
    struct neat_ctx *ctx;
    struct neat_flow *flow;
    struct neat_flow_operations ops;

    ctx  = neat_init_ctx();
    flow = neat_new_flow(ctx);
    memset(&ops, 0, sizeof(ops));

    ops.on_connected = on_connected;
    neat_set_operations(ctx, flow, &ops);

    neat_set_property(ctx, flow, properties);

    if (neat_open(ctx, flow, "127.0.0.1", 8080, NULL, 0)) {
        fprintf(stderr, "neat_open failed\n");
        return EXIT_FAILURE;
    }

    neat_start_event_loop(ctx, NEAT_RUN_DEFAULT);

    neat_free_ctx(ctx);

    return EXIT_SUCCESS;
}
